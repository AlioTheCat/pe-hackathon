#input : (.....   ...........)
#         <-N->   <---h*w--->

import numpy as np

def flatten(N, shape_id, pos_matx, obst_grid):
    N = len(d)
    id_vector = np.zeros(N)
    id_vector[shape_id] = 1
    location_vector = pos_matx[~obst_grid.astype('bool')]
    return np.concatenate((id_vector, location_vector))



def piece_matx_list(piece_dictionnary) :
    N = len(piece_dictionnary.keys())
    return sum([piece_dictionnary[i] for i in range(N)],
               start = []) # Pour conserver l'ordre

def piece_flattened_list(N, piece_dictionnary, obst_grid) :
    return sum([[flatten(N, i, matx, obst_grid) for matx in piece_dictionnary[i]] for i in range(N)],
               start = [])


"""
## Tests ##

d= {1: [np.array([[0,1],[0,1]])],
    2: [np.array([[0,0],[0,1]]), np.array([[0,0],[1,0]]), np.array([[0,1],[0,0]])]}

obst_grid = np.array([[1,0],
                      [0,0]])
    
print(piece_matx_list(d))

print(piece_flattened_list(2, d, obst_grid))
"""





def get_shape_id(flat_vect):
    return flat_vect.argmax() + 1

def convert_solution_to_matx(solution, flat_vect_list, pos_matx_list, N, h, w):
    """
    solution : list d'indices correspondant aux matrices-pi√®ces dans []
    """
    
    return sum([get_shape_id(flat_vect_list[piece])*pos_matx_list[piece] for piece in solution],
               start=np.zeros((h,w), dtype=int))

