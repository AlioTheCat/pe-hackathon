#input : (.....   ...........)
#         <-N->   <---h*w--->

import numpy as np

def flatten(N, shape_id, pos_matx, obst_grid):
    #N = len(d.keys())
    id_vector = np.array([int(i==shape_id) for i in range(N)])
    location_vector = pos_matx[~obst_grid.astype('bool')]
    return np.concatenate((id_vector, location_vector))

def get_shape_id(flat_vect):
    return flat_vect.argmax() + 1

def solution_to_matx(solution, flat_vect_list, pos_matx_list, N, h, w):
    """
    solution : list d'indices correspondant aux matrices-pi√®ces dans []
    """
    
    return sum([get_shape_id(vect_list[piece])*pos_matx_list[piece] for piece in solution],
               start=np.zeros((h,w)))



def piece_matx_list(piece_dictionnary) :
    N = len(piece_dictionnary.keys())
    return sum([piece_dictionnary[i] for i in range(N)], start = []) # Pour conserver l'ordre

def piece_flattened_list(piece_dictionnary) :

pos_matx_list = 
    
    